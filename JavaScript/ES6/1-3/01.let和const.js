/*
  ES6新增let命令 用来声明变量 类似于var 但是var是全局有效的 而let只是在代码块内有效
  这样的设计在for循环里面非常安全 所以在for循环中要求都使用let去声明变量

  let命令：
    特点：
      1、let只在代码块内有效
      2、不存在变量提升 需要先声明后使用
      3、存在暂时性死区
        这和第二点差不多，只要块级作用域内存在过let声明的变量，那么在这个变量声明之前你都不可以对改变量进行操作
        比如块外有个全局变量a，块中有let变量a，那么在块中的let a变量声明之前你都不能对a变量进行任何操作
        这样的特性会使typeof也不再是一个百分百安全的操作 如果域内没有变量 那么该操作会返回“undefined”
        如果域内有该let变量被声明 那么在这个声明之前使用typeof操作 则会抛出异常

      4、不允许重复声明
*/

// 特点1：let只在代码块内有效
// 下面这样的结果 10个函数都会打印10 因为i是一个全局变量 i一变 所有的函数输出都会变
var a = []
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}
a[4]()

var b = []
for (let i = 0; i < 10; i++) {
  b[i] = function () {
    console.log(i)
  }
}
b[4]()

/*
  const命令：
    1、该命令声明一个只读常量，一旦被声明就不可被改变，而且声明的同时必须赋值，否则也报错。
    2、同样也只在块级作用域中有效
*/

/*
  全局对象是属性：
    全局对象是最顶层的对象，在浏览器环境下是window对象，在nodejs中是global对象。
    未声明的全局变量，自动成为全局对象的属性，在es5中这被认为是js设计的最大败笔，
    为了改变这点，但是也为了保持兼容性，我们规定：
      var和function命令声明的全局变量，依旧是全局对象的属性。
      let、const、class声明的全局变量，不属于全局对象的属性。
*/
